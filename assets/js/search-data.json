{
  
    
        "post0": {
            "title": "Magic in Numpy",
            "content": "Numpy Basics . We will now go over some basic approaches on a seemingly simple matrix for illustrative purposes. Hopefully some of the efficient and useful properties of Numpy become apparent. . A favorite work by a favorite artist, Dürer&#39;s Melencolia I (1514) includes sophisticated use of mathematical allegory, particularly in the top-right corner. . . . The matrix is thus: . import numpy as np X = np.array([[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]) print(X) . [[16 3 2 13] [ 5 10 11 8] [ 9 6 7 12] [ 4 15 14 1]] . type(X) . numpy.ndarray . Magic Squares . This matrix is purported to be a magic square. We must fit the following constraints: . 1) Magic 2) Square . Simple enough. Starting with the second condition, Numpy provides a number of methods. Though magic cubes and tesseracts are possible, we can begin with a square. Here&#39;s a simple function to detect if an array is square. . def is_square(M: np.ndarray) -&gt; bool: &#39;&#39;&#39; Arguments: M, a 2-d matrix Returns: a boolean, True if square &#39;&#39;&#39; assert M.ndim == 2 return True if M.shape[0] == M.shape[1] else False is_square(X) . True . Vectorized Summation: Magic . Now, the more involved condition. A square is &quot;magic&quot; iff the array exhibits the following properties: . i) Each of the $n$ elements are of the set of distinct positive integers $[1,2,3,...,n^2]$, such that $n$ is the &quot;order&quot; of the square. Dürer thus presents a $4^{th}$ order magic square. . ii) The sum of the $n$ numbers about any horizontal, vertical or main diagnonal is the same number – the &quot;magic&quot; constant. It is known that such magic constants can be given by $ mathcal{M}(X_n) = frac{1}{n} sum_{k=1}^{n^2}k = frac{1}{2}n(n^2+1)$ . . Aside: iii) The complement to a magic square is derived from subtracting every number in a given magic square by $n^2 + 1$. . Back to Dürer. We can check each condition as follows. . def is_magic(M:np.ndarray)-&gt;bool: #By constraints i) &amp; ii) assert M.shape[0] == M.shape[1], &#39;Not a square.&#39; n = M.shape[0] assert np.array_equal(np.sort(M.flatten()), np.arange(n**2) + 1), &#39;Expected elements from [1,2,...,n^2]&#39; column_sums = np.sum(M,axis=0) #Note that summing across axis 0 actually returns column-wise sums, and vice-versa. row_sums = np.sum(M, axis=1) diagonal_sums = np.array([np.trace(M),np.trace(np.fliplr(M))]).astype(int) magic_num_sum = np.unique(np.concatenate( (column_sums,row_sums,diagonal_sums) )) if len(magic_num_sum) == 1: print(f&#39;Magic number is {magic_num_sum} with order {n}.&#39;) return True . np.fliplr(X).diagonal().sum() == np.flipud(X).diagonal().sum() . True . np.trace(X) == np.diagonal(X).sum() . True . is_magic(X) . Magic number is [34] with order 4. . True . X . array([[16, 3, 2, 13], [ 5, 10, 11, 8], [ 9, 6, 7, 12], [ 4, 15, 14, 1]]) . Fast Indexing: Gnomon Magic . Dürer&#39;s square is actually a Gnomonic Magic Square – that is, each non-overlapping root subsquare bordering the four sides of the square ($2 times 2$ subsquare), as well as the central subsquare, sums to the magic constant of the overarching square. . The Gnomon is the portion of the sundial casting a shadow. In a way we also cast a magic projection on subarrays of our main magic square. . We can verify this easily – in Numpy, arrays can be efficiently split with minimal logic, rather than looping over each element and hard-indexing. . a,b,c,d = [quadrant for sub_x in np.split(X,2, axis = 0) for quadrant in np.split(sub_x,2, axis = 1)] n = X.shape[0] n_subsquare = np.sqrt(n).astype(int) start = n//2 - (n_subsquare // 2) end = n//2 + (n_subsquare // 2) e = X[start:end,start:end] sections = [a, b, c, d, e] sections . [array([[16, 3], [ 5, 10]]), array([[ 2, 13], [11, 8]]), array([[ 9, 6], [ 4, 15]]), array([[ 7, 12], [14, 1]]), array([[10, 11], [ 6, 7]])] . print(set([sum(s.flatten()) for s in sections])) . {34} . All quadrants sum to the magic number of 34. As such, we have verified the deliberate style of Dürer. . Linear Algebra .",
            "url": "https://simonlevine.github.io/simonsays/jupyter/2021/01/04/linear-algebra.html",
            "relUrl": "/jupyter/2021/01/04/linear-algebra.html",
            "date": " • Jan 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Tensors via Bioimaging",
            "content": "Background . 1.3 billion humans are able to use Microsoft Excel. Microsoft Excel is the modern clay tablet, an intuitive but ultimately limited instrument for the computational professional. After all, why should we be limited to two dimensions? Why should we pay for the priveledge? Often, data is best represented as $n$-dimensional. . For instance, let&#39;s say you&#39;d like become a billionaire without too much effort. One way would be to totally automate clinical bioimage analysis at human-level fidelity using machine learning. . . A Diabetic retinopathy slide (https://www.kaggle.com/c/diabetic-retinopathy-detection). The condition is estimated to affect over 93 million people. . Whereas a highly skilled human could potentially spot abnormalities in the above retinopathy slide, a machine can do it better and much faster. Partially, this is because a machine views the below image somewhat naïvely as 150,528 dots, as we have a square RGB image with with 224 pixels per dimension. . Viewing the image not as an image but as a tensor, we simply vector-valued matrices, or an $n$-dimensional generalization of a matrix, we can then move onto analyzing the image: segmentation, feature learning, classification (if labels are detected), and other interesting tasks that a human may or may not be able to do. . Numpy . We use Numpy for efficient vectorized tensor manipulation with the convenient abstraction of the Python programming language. Numpy fuency will carry a computational professional very far, and it will only begin to show limitations when deep learning and very large datasets are involved (though the syntax of major deep learning packages are very close to Numpy) . We can easily load the above png &quot;image&quot; into a numpy array using a number of packages. imageio is used below. . import imageio import numpy as np my_image = imageio.imread(&#39;10009_right.png&#39;) my_image . Array([[[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]], ..., [[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], ..., [0, 0, 0], [0, 0, 0], [0, 0, 0]]], dtype=uint8) . Above we see the image loaded into memory as an integer-valued 3-dimensional matrix. Basic Numpy / Python fluency is assumed (slicing, etc.). . my_image.shape #note memory persistence in Jupyter. . (224, 224, 3) . my_image.size . 150528 . my_image.ndim . 3 . The $224 times 224 times 3$, $150,528$-element, $3$-dimensional array can be now be subject to a multitude of useful manipulations. . For instance, we can sparsify the matrix using scipy.sparse for 2-d matrices and sparse (!pip install sparse) for $n$-dimensional arrays (tensors). This may be useful for quick compression or storage of many such images: note the large number of zero values corresponding to &quot;black&quot; portions of the image. . import sparse sparse.COO(my_image) . Formatcoo | . Data Typeuint8 | . Shape(224, 224, 3) | . nnz120885 | . Density0.8030731823979592 | . Read-onlyTrue | . Size2.9M | . Storage ratio20.1 | . The sparse matrix in general is less memory intensive. . Another example of manipulation: we can quickly invert and flip the image with numerical rigor. We will use matplotlib to display the numpy array. . np.invert is np.bitwise_not . True . import matplotlib.pyplot as plt plt.imshow(my_image) plt.axis(&#39;off&#39;) plt.title(&#39;All Axes&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; plt.imshow(np.invert(my_image)) plt.axis(&#39;off&#39;) plt.title(&#39;Inverted (Bitwise NOT; twos-complement)&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; Said another way... . 255 - my_image[100,100,:] == np.invert(my_image)[100,100,:] #we are in 256-bit color. . Array([ True, True, True]) . plt.imshow(np.fliplr(my_image)) plt.axis(&#39;off&#39;) plt.title(&#39;Flipped (LR)&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; This leads to some intuitive operations. For instance, if we were looking to feature-engineer such image data for use in a statistical learning classifier, we may hypothesize the location of the fovea (bright central spot) as a useful aspect of the retinopathy image. . I&#39;m betting we can segment these features with a single line of numpy. For this and subsequent examples, let&#39;s take a sample of the first sheet (zeroth index) of the image for simplicity such that we have a 2-d array (pretend we read-in a greyscale image). . x = my_image[:,:,0] #take all elements of the first sheet/leaf of the array. plt.imshow(x) plt.axis(&#39;off&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; Now for the single line. We will find the bright portion by the assumption that we can find it by taking $region = frac{ sum_i x_i}{N} * 2 * sigma( vec{x})$, or all pixels with intensity greater than equal to two standard deviations above the mean. . x = my_image[:,:,0] #take all elements of the first sheet/leaf of the array. mask = (x &gt;= x.mean() + 2*x.std()) . plt.imshow(mask) plt.axis(&#39;off&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; We can then get the coordinates in the array simply: . coords = np.argwhere(x == mask) coords . array([[ 0, 0], [ 0, 1], [ 0, 2], ..., [223, 221], [223, 222], [223, 223]]) . print(coords.size) . 20656 . If we knew a priori that a particular type of retinopathy was characterized by abnormal foveal locations, and we had a sufficient train/test/validation dataset, we could reduce the size of our dataset significantly with such an engineered feature. . print(f&#39;If we only require foveal coordinates, our dataset may be reduced by {round(100-(coords.size/my_image.size)*100,2)}% !&#39;) . If we only require foveal coordinates, our dataset may be reduced by 86.28% ! . In Closing... . I hope this example was helpful in showing how we can quickly prepare complex data types for computational purposes. I will return to abstract bioimaging processing in future posts. .",
            "url": "https://simonlevine.github.io/simonsays/jupyter/2020/12/31/tensors.html",
            "relUrl": "/jupyter/2020/12/31/tensors.html",
            "date": " • Dec 31, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "It's better to be evil than boring",
            "content": "Background . Healthcare is, apart from university tuition, one of the more rapidly inflating services on the market. Inconvenient as it might be, much of the reason behind the crushing costs of paying for healthcare has little to do with what you might expect. The price of the cancer drug crizotinib was actually developed on a shoestring, judging by the name. And yeah, it stings to think about how our copayments trickle their way into the Mercedes-AMG option sheet between some surgeon&#39;s sweaty thumbs, but there aren&#39;t that many surgeons. In reality, a large reason behind cost inflation in healthcare has nothing to do with the evil stuff. It has to do with the boring stuff. . In this post, I will look at a major chapter of the administrative nightmare of healthcare: manual medical coding. We will quickly see how a large cost center in administration will likely be totally automated in the near future, and my hope is that you will be left wondering how this is still possibly done largely by hand. .",
            "url": "https://simonlevine.github.io/simonsays/jupyter/2020/12/31/boring.html",
            "relUrl": "/jupyter/2020/12/31/boring.html",
            "date": " • Dec 31, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "(simple) Autoencoders ≡ PCA",
            "content": "Background . Shocker: The simplest autoencoder is actually the same as PCA. We will also see how VAEs perform expectation maximization. .",
            "url": "https://simonlevine.github.io/simonsays/jupyter/2020/12/31/autoencoders.html",
            "relUrl": "/jupyter/2020/12/31/autoencoders.html",
            "date": " • Dec 31, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://simonlevine.github.io/simonsays/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Originally from a small town in northern California, I completed my B.A. in biolical sciences with a minor in mathematical finance at the University of Southern California. . I then spent about a year in consulting and briefly worked at a winery. I also devoted a considerable amount of time and effort on the law school admissions test (LSAT) but realized the profession was not for me. Instead, I chose to return toward technical topics and decided to pursue the master’s program in computational biology at Carnegie Mellon University. . At CMU, I’ve worked toward mastering an understanding of statistical and deep learning methods as they relate to the biosciences. Some of my favorite coursework includes 02-710: Computational Genomics, and the infamous 11-785: Deep Learning. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://simonlevine.github.io/simonsays/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://simonlevine.github.io/simonsays/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}